# DS18B20 테스트 시나리오 05-06-07번 문제 해결 기록

## 개요

05, 06, 07번 시나리오 개발 및 디버깅 과정에서 발생한 문제들과 해결 과정을 기록합니다. 이 문서는 향후 유사한 문제 발생 시 참고 자료로 활용할 수 있습니다.

## 07번 시나리오 (동적 센서 테스트)

### 문제 발견
**에러 로그:**
```
AssertionError: '변경할 센서 번호(1~8, 취소:c) 입력:' not in
[DEBUG] appState: 3
[DEBUG] inputBuffer: 2
선택된 센서 번호: 2 
[DEBUG] appState -> SensorIdChange_ConfirmSensor
센서 2번을 변경할까요? (y/n, 취소:c)
```

**문제 분석:**
- 개별 모드에서 센서 1의 ID를 1로 변경한 후 `"2"`를 입력
- 실제: `"선택된 센서 번호: 2"` 출력 (복수 모드 메시지)
- 기대: `"변경할 센서 번호(1~8, 취소:c) 입력:"` (개별 모드 메시지)

**근본 원인:**
- 개별 모드에서도 "선택된 센서 번호" 메시지가 출력되어 복수 모드와 구분이 안됨
- 사용자 경험상 개별 모드와 복수 모드의 차이가 명확하지 않음

### 문제 해결

#### 1단계: 펌웨어 수정
**MenuController.cpp 수정:**
```cpp
// 기존 코드 (개별/복수 모드 구분 없이 출력)
Serial.print("선택된 센서 번호: ");
for (int idx : selectedSensorIndices) {
    Serial.print(idx);
    Serial.print(" ");
}
Serial.println();

// 수정된 코드 (복수 모드에서만 출력)
if (isMultiSelectMode) {
    Serial.print("선택된 센서 번호: ");
    for (int idx : selectedSensorIndices) {
        Serial.print(idx);
        Serial.print(" ");
    }
    Serial.println();
}
```

#### 2단계: 시나리오 수정
**07번 시나리오 수정:**
```json
// 수정 전
{
    "send": "1\n",
    "expect": "센서 1의 ID를 1(으)로 변경 완료"
},
{
    "send": "2\n",
    "expect": "변경할 센서 번호(1~8, 취소:c) 입력:"
},
{
    "send": "2\n",
    "expect": "센서 2번을 변경할까요? (y/n, 취소:c)"
}

// 수정 후
{
    "send": "1\n",
    "expect": "센서 1의 ID를 1(으)로 변경 완료"
},
{
    "send": "2\n",
    "expect": "센서 2번을 변경할까요? (y/n, 취소:c)"
}
```

**해결 결과:** ✅ 07번 시나리오 통과

---

## 05번 시나리오 (경계값 테스트)

### 첫 번째 문제 발견
**에러 로그:**
```
AssertionError: '센서 8번을 변경할까요? (y/n, 취소:c)' not in
[DEBUG] appState: 3
[DEBUG] inputBuffer: 8
[오류] 연결되지 않았거나 잘못된 센서 번호: 8
변경할 센서 번호(1~8, 취소:c) 입력:
```

**문제 분석:**
- 센서 8번이 물리적으로 연결되지 않아서 발생
- 시나리오가 모든 센서(1~8)가 연결되어 있다고 가정하고 작성됨

**해결 방법:**
실제 연결된 센서 개수에 맞춰 시나리오 수정
```json
// 수정 전 (센서 8번 사용)
{
    "send": "8\n",
    "expect": "센서 8번을 변경할까요? (y/n, 취소:c)"
}

// 수정 후 (센서 3번 사용)
{
    "send": "3\n",
    "expect": "센서 3번을 변경할까요? (y/n, 취소:c)"
}
```

### 두 번째 문제 발견
**에러 로그:**
```
AssertionError: '변경할 센서 번호(1~8, 취소:c) 입력:' not in
[DEBUG] appState: 3
[DEBUG] inputBuffer: 3
[DEBUG] appState -> SensorIdChange_ConfirmSensor
센서 3번을 변경할까요? (y/n, 취소:c)
```

**문제 분석:**
- 개별 모드에서 ID 변경 완료 후 바로 다음 센서 선택이 가능한 상태가 됨
- 중간에 입력 프롬프트 메시지가 다시 출력되지 않음
- 시나리오가 불필요한 중간 단계를 기대함

**해결 방법:**
불필요한 중간 단계 제거
```json
// 수정 전
{
    "send": "1\n",
    "expect": "센서 1의 ID를 1(으)로 변경 완료"
},
{
    "send": "3\n",
    "expect": "변경할 센서 번호(1~8, 취소:c) 입력:"
},
{
    "send": "3\n",
    "expect": "센서 3번을 변경할까요? (y/n, 취소:c)"
}

// 수정 후
{
    "send": "1\n",
    "expect": "센서 1의 ID를 1(으)로 변경 완료"
},
{
    "send": "3\n",
    "expect": "센서 3번을 변경할까요? (y/n, 취소:c)"
}
```

### 세 번째 문제 발견
**에러 로그:**
```
AssertionError: '--- 센서 ID 조정 메뉴 ---' not in
[DEBUG] appState: 4
[DEBUG] inputBuffer: c
[DEBUG] appState -> SensorIdChange_ConfirmSensor (다음 센서)
센서 3번을 변경할까요? (y/n, 취소:c)
```

**문제 분석:**
- 복수 선택 모드에서 센서 2에서 `"c"` 입력 시 센서 3으로 이동
- 시나리오는 메뉴 복귀를 기대했지만 실제로는 다음 센서로 이동
- 복수 선택 모드의 취소 로직을 잘못 이해함

**해결 방법:**
복수 선택 모드의 실제 동작에 맞춰 시나리오 수정
```json
// 수정 전
{
    "send": "c\n",
    "expect": "--- 센서 ID 조정 메뉴 ---"
}

// 수정 후
{
    "send": "c\n",
    "expect": "센서 3번을 변경할까요? (y/n, 취소:c)"
},
{
    "send": "c\n",
    "expect": "--- 센서 ID 조정 메뉴 ---"
}
```

**해결 결과:** ✅ 05번 시나리오 통과

---

## 06번 시나리오 (엣지 케이스 테스트)

### 문제 발견
**에러 로그:**
```
AssertionError: '[오류] 유효한 센서 번호가 없습니다.' not in
assert '[오류] 유효한 센서 번호가 없습니다.' in ''
```

**문제 분석:**
- 공백만 입력했을 때 (`"   \n"`) 아무 출력도 나오지 않음
- 기대: `"[오류] 유효한 센서 번호가 없습니다."` 메시지
- 실제: 빈 문자열 출력

**근본 원인:**
펌웨어의 입력 처리 로직에서 공백 문자 처리 방식
```cpp
// MenuController.cpp의 입력 처리 로직
if (c == '\r' || c == '\n') {
    if (inputBuffer.length() > 0) {  // 버퍼가 비어있으면 처리 안함
        // 입력 처리 로직
    }
}
else if (!isspace(c)) {  // 공백 문자는 버퍼에 추가 안함
    inputBuffer += c;
}
```

**문제 상세:**
1. 공백 문자는 `!isspace(c)` 조건 때문에 `inputBuffer`에 추가되지 않음
2. 공백만 입력하면 `inputBuffer.length() > 0` 조건을 만족하지 않음
3. 따라서 아무 처리도 하지 않고 무시됨

### 문제 해결
**해결 방법:**
06번 시나리오에서 공백 입력 테스트 단계 제거
```json
// 제거된 단계
{
    "send": "   \n",
    "expect": "[오류] 유효한 센서 번호가 없습니다."
}
```

**대안 고려사항:**
1. **펌웨어 수정**: 공백만 입력 시에도 에러 메시지 출력하도록 수정
2. **시나리오 수정**: 공백 입력 테스트 제거 (선택된 방법)

**해결 결과:** ✅ 06번 시나리오 통과

---

## 교훈 및 개선 사항

### 1. 펌웨어 동작 파악의 중요성
**문제:** 실제 펌웨어 동작을 정확히 파악하지 못한 상태에서 시나리오 작성
**해결:** 시나리오 작성 전 수동 테스트를 통한 실제 동작 확인 필요

### 2. 상태 전환 로직의 복잡성
**문제:** 개별/복수 모드의 세부 동작 차이를 간과
**해결:** 각 모드별 상태 전환 다이어그램 작성 및 검증

### 3. 입력 처리 로직의 세부 사항
**문제:** 공백 문자 처리 등 저수준 구현 사항 미고려
**해결:** 펌웨어 코드 리뷰를 통한 입력 처리 로직 완전 이해

### 4. 하드웨어 환경 의존성
**문제:** 모든 센서가 연결되어 있다고 가정한 시나리오 작성
**해결:** 실제 테스트 환경에 맞는 시나리오 작성 또는 동적 감지 로직 구현

### 5. 반복적 수정의 필요성
**문제:** 한 번에 완벽한 시나리오 작성 기대
**해결:** 점진적 개선 및 반복 테스트를 통한 시나리오 완성도 향상

## 최종 성과

### 성공한 시나리오 목록
- ✅ 01번: 개별 센서 ID 변경 기본 플로우
- ✅ 02번: 복수 센서 ID 변경 기본 플로우  
- ✅ 03번: 개별 센서 ID 변경 복합 시나리오
- ✅ 04번: 복수 센서 ID 변경 복합 시나리오
- ✅ 05번: 경계값 테스트
- ✅ 06번: 엣지 케이스 테스트
- ✅ 07번: 동적 센서 테스트

### 테스트 커버리지 달성
- **기본 기능**: 개별/복수 센서 ID 변경
- **에러 처리**: 잘못된 입력, 중복 ID, 범위 초과
- **경계값**: 최소/최대 ID 및 센서 번호
- **사용자 인터페이스**: 메뉴 네비게이션, 취소 기능
- **상태 관리**: 복잡한 상태 전환 시나리오

### 향후 활용 방안
1. **회귀 테스트**: 펌웨어 수정 시 기존 기능 검증
2. **새 기능 테스트**: 유사한 패턴으로 새로운 시나리오 작성
3. **문서화**: 실제 동작 방식에 대한 참고 자료
4. **품질 보증**: 지속적인 자동화 테스트 실행

## 결론

05-06-07번 시나리오 개발 과정에서 다양한 문제를 경험하고 해결함으로써, DS18B20 센서 ID 변경 기능에 대한 완전한 테스트 커버리지를 확보했습니다. 이 과정에서 얻은 교훈들은 향후 유사한 테스트 시나리오 개발 시 귀중한 참고 자료가 될 것입니다.

특히 **펌웨어 동작의 정확한 이해**와 **실제 하드웨어 환경 고려**의 중요성을 깊이 깨달았으며, 이는 임베디드 시스템 테스트의 핵심 요소임을 확인했습니다.