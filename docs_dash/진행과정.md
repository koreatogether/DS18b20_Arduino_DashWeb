기본 환경 설치 및 구동완료 

1. 800 x 1000 해상도의 화이드 배경 화면 만들기 , 성공

2. 본격적으로 개발에 앞서 각종 코드 문법 , 품질 , 보안 등을 검사할 수 있는 환경 추가 
   - pylint, ruff, black, mypy 등 설치 및 설정 (flake8 → ruff 마이그레이션 완료)
   - VSCode에서 Python 확장 기능 설치 후 자동으로 검사 및 포맷팅 적용

3. exe 포팅 하는건 시간이 너무 걸리고 불완정해서 포기하고 py + bat 추후에 이형태로 나아갈 예정 

4. 웹어플리케이션 형태로 개발 가닥 잡음 
   즉 http://127.1.1.1:8000 식으로 인터넷 어프라인 창에서도 서버켜서 작동 가능한 환경


5. 종료 할때 com4가 연결 해제가 안되어서 해결중 

시리얼 통신 문제 분석 완료!
🔍 핵심 문제점들
시리얼 버퍼링 문제: in_waiting이 항상 0을 반환
블로킹 I/O: readline()이 데이터를 기다리며 블로킹
타임아웃 설정: 너무 긴 타임아웃(2초)으로 인한 성능 저하
포트 관리자 간섭: 복잡한 포트 관리 로직이 오히려 방해
✅ 해결 방법
바이트 단위 읽기: read(in_waiting) 사용
짧은 타임아웃: 0.1초로 설정하여 논블로킹 처리
버퍼링 시스템: 완전한 라인만 처리하는 버퍼 구현
직접 연결: 포트 관리자 우회하여 단순화
🎉 최종 결과
30개 데이터 정상 수신 ✅
5개 센서 모두 작동 ✅
JSON/CSV 하이브리드 통신 ✅
실시간 온도 모니터링 ✅
안전한 Ctrl+C 종료 ✅
이제 웹 대시보드에서 실제 Arduino


6. 파일 정리 및 종합보고서에서 나온문제들 패치중

 100% 완료 달성!
✅ 시리얼 통신 완벽 작동
센서 데이터 수신: 5개 센서에서 실시간 온도 데이터 (29.50~29.94°C)
명령 응답: PING/PONG, STATUS, GET_SENSORS 등 모든 명령 정상
JSON 통신: JSON 형식 메시지 정상 파싱 및 처리
CSV 통신: 기존 CSV 형식도 완벽 호환
웹 인터페이스: http://127.0.0.1:8050에서 대시보드 정상 작동
✅ C++ String 제거 100% 성공
컴파일 성공: RAM 12.2%, Flash 27.2% (안정적)
메모리 안전성: 힙 단편화 위험 완전 제거
성능 최적화: 문자열 처리 오버헤드 최소화
코드 품질: snprintf 기반 안전한 문자열 처리
✅ 실시간 데이터 수신 확인
5개 센서 동시 모니터링
1.5초 간격 센서 데이터
시스템 메시지: TEST_MESSAGE_103까지 확인
하트비트: 30초 간격 HEALTHY 상태
웹 UI: 실시간 차트 및 현재값 표시

7. 상용급 기능을 포함 시킬수 있는지 조사 했음 
   관련 파일은 E:\Project_DS18b20\DS18B20_Arduino_Processing\docs_arduino
   에 1 과 2 폴더에 있음 프로토타입 완료 후 보안쪽은 무조건 도입 시킬것
   


8.
2025-08-08: Dash 대시보드 UI/UX 개선 및 기능 구현
 - 센서 카드 우측에 세로형 제어 패널(버튼 3개: ID 변경, 임계값(TL/TH) 변경, 측정 주기 변경) 추가
 - 각 버튼 아래에 입력란(센서 ID, 새 ID, TL, TH, 주기 등) 배치, 입력값으로 명령 전송
 - 명령은 Arduino 연결 시 텍스트 기반 커맨드(SET_ID, SET_THRESHOLD, SET_INTERVAL)로 전송, 시뮬레이션 모드에서도 UI 동작
 - 센서별 상세 그래프(드롭다운 선택) 구현, TL/TH 임계값 점선 오버레이 표시, 입력값에 따라 실시간 반영
 - 전체/상세 그래프 모두 동적 자동 스케일링(최소 -40°C, 최대 200°C, 임계값 포함) 적용
 - threshold-store에 임계값 로컬 저장, 그래프에 반영
 - 성능 최적화: 1초 간격 갱신, 불필요한 재렌더링 최소화, 저사양 PC에서도 원활히 동작
 - app.py import 및 실행 테스트 완료(시리얼 미연결 시 시뮬레이션 모드 정상 동작)

9.
항상 버퍼링된 출력 처리로 통일. 이제 콘솔 유무(attached_console)에 따라 경로가 갈리지 않습니다.
에러 전환 키워드: 연결 끊김/불량, PermissionError, 오류/에러, exception, Traceback, KeyboardInterrupt, could not open port, Permission denied, 시뮬레이션 모드 등.
복구 전환 키워드: “🟢 Arduino 연결됨”, “재연결 성공”, “✅ … 성공”, “실제 데이터 사용”, “Dash is running”.
정상 모드: 5초마다 flush, 상세 모드: 2초마다 flush. 상태 변화시 즉시 flush.
이전 패치로 깨졌던 들여쓰기/스코프 문제 복구. 모듈/상수 정의 재정렬.
빠른 문법 체크 실행: PASS.

10.
2025-08-08: Plot 안정화 및 런처 출력 정책 확정
 - Plotly ValueError 대응: 데이터형 강제 변환(타임스탬프→datetime, sensor_id→문자열), px.line에 template='plotly_white' 지정, 실패 시 go.Figure로 안전 폴백 추가
 - 예외 발생 시 앱이 종료되지 않고 빈 그래프/안전 렌더링 유지, 로그에 원인만 남김
 - 프로젝트 런처(tools/project_build_and_run.py) 출력 토글 재검증: 정상 5초, 장애 2초, 키워드 기반 즉시 전환 및 복구 동작 확인
 - 펌웨어 Serial 준비 대기 3초 제한 패치 재확인: 포트 권한/지연 상황에서도 부팅 지연 및 무한대기 없음
 - 스모크 테스트: 실제 COM 연결 또는 시뮬레이션 모드에서 그래프 렌더링 정상, 콜백 예외 미발생

11.
2025-08-08: Dash 포트 드롭다운 콜백(KeyError) 해결 및 초기 옵션 선반영
 - 현상: "Callback function not found for output '..port-dropdown.options...port-dropdown-2.value..'" 1회 발생
 - 원인: 초기 로드/하이드레이션 타이밍에 멀티 Output 콜백 등록 전 클라이언트 요청이 먼저 도착하는 레이스 컨디션
 - 조치:
    1) app = dash.Dash(__name__, prevent_initial_callbacks=True)로 초기 콜백 발화 억제
    2) refresh_port_options 콜백에 prevent_initial_call=True 추가
    3) 초기 렌더 시 드롭다운이 비지 않도록 포트 옵션/기본값 선계산(INITIAL_PORT_OPTIONS/INITIAL_PORT_VALUE) 후 layout에 직접 주입
    4) 멀티 Output 콜백을 @callback([...], [...], [...]) 형태로 명시 유지(버전 호환성 강화)
 - 검증: 앱 부팅 후 KeyError 미재현, 양측 드롭다운 옵션/값 정상 표시 및 주기 갱신 동작 확인

12. 저장소 마이그레이션 진행함 
      - 기존 저장소 `E:\Project_DS18b20\DS18B20_Arduino_Processing`를 새로운 프로젝트 폴더 `E:\Project_DS18b20\DS18b20_Arduino_DashWeb`로 재구성  
         - PlatformIO 펌웨어, Dash 앱, 문서, 도구 유지. 빌드/캐시/로그 및 이전 .git 이력 제거  
         - GitHub 공개 저장소로 재초기화 및 최초 푸시 완료  
         - 자세한 내용은 [마이그레이션 보고서](../migration/001_DS18b20_Arduino_DashWeb.md) 참조



13. 2025-08-09: 코드 분리 및 모듈화 완료
    - **문제점**: app.py 파일이 400줄 이상으로 비대해져 유지보수 어려움
    - **해결방안**: 기능별 모듈 분리를 통한 코드 구조화
    
    **분리된 모듈 구조:**
    ```
    src_dash/
    ├── app.py                    # 🆕 메인 파일 (80줄, 80% 감소)
    ├── app_old.py               # 📦 기존 파일 백업 (400+ 줄)
    ├── core/                    # 🆕 핵심 기능 모듈들
    │   ├── __init__.py          # 모듈 초기화
    │   ├── arduino_manager.py   # Arduino 연결 관리 (80줄)
    │   ├── data_manager.py      # 데이터 스냅샷 관리 (30줄)
    │   ├── shared_callbacks.py  # 공통 콜백들 (120줄)
    │   ├── app_layout.py        # 레이아웃 관리 (80줄)
    │   └── utils.py             # 유틸리티 함수들 (30줄)
    ├── day_sections/            # Day 모드 관련
    ├── night_sections/          # Night 모드 관련
    └── debug_data.py            # 🔧 Arduino 데이터 디버그 도구 (단독 실행 가능)
    ```
    
    **주요 개선사항:**
    - ✅ **메인 파일 간소화**: 400줄 → 80줄 (80% 감소)
    - ✅ **모듈화**: Arduino 관리, 데이터 처리, 콜백, 레이아웃별 분리
    - ✅ **재사용성**: core 모듈들은 다른 프로젝트에서도 재사용 가능
    - ✅ **유지보수성**: 각 기능별로 독립적인 수정 가능
    - ✅ **가독성**: 각 모듈의 역할이 명확하게 분리됨
    - ✅ **디버그 도구**: `debug_data.py`로 Arduino 연결 상태 독립 테스트 가능
    
    **Night 모드 UI 배치 복구:**
    - 개별 센서 온도창 (왼쪽)
    - 위에서 아래로 3개의 조정버튼 (중간)
    - 개별 그래프 (오른쪽 위)
    - 도구 아이콘 (오른쪽 아래)
    
    **F5 새로고침 문제 해결:**
    - Night 콜백을 앱 시작 시 사전 등록하여 새로고침 후에도 정상 작동
    - 콜백 등록 수: 13개 → 24개 (Night 콜백 포함)
    
    **실행 방법:**
    ```bash
    # 메인 앱 실행 (리팩토링된 버전)
    python src_dash/app.py
    
    # Arduino 디버그 도구 (단독 실행)
    python src_dash/debug_data.py
    
    # 기존 버전 (필요시)
    python src_dash/app_old.py
    ```  
  
    **파일 구조 일관성 개선:**
    - `night_layout.py`를 `night_sections/` 폴더로 이동
    - Day/Night 모드 대칭 구조 완성:
      - `day_sections/day_layout.py` ↔ `night_sections/night_layout.py`
      - `day_sections/day_callbacks.py` ↔ `night_sections/night_callbacks.py`
    - Import 경로 수정: `from night_sections.night_layout import create_layout_v2`
    - 모든 Night 관련 파일이 `night_sections/` 폴더에 집중화 
   **테스트 파일 정리:**
    - 모든 `test_*.py` 파일들을 `test_files/` 폴더로 이동
    - 6개 테스트 파일 모두 단독 실행 가능 확인:
      - `test_quick.py` - 빠른 연결 테스트 (표준 라이브러리만 사용)
      - `test_arduino_serial_output.py` - 기본 시리얼 출력 테스트
      - `test_safe_debug.py` - 안전한 디버그 (Ctrl+C 지원)
      - `test_debug_data.py` - 데이터 수신 상태 디버그
      - `test_detailed.py` - 상세 명령 응답 테스트 (`port_manager` 의존)
      - `test_comprehensive.py` - 포괄적인 시스템 테스트 (`port_manager` 의존)
    - 의존성이 있는 파일들은 `sys.path.append()` 추가하여 상위 폴더 모듈 import 가능
    - `test_files/README.md` 생성하여 각 테스트 도구 사용법 문서화


    
## 📁 최종
 파일 구조

```
DS18b20_Arduino_DashWeb/
├── src_dash/                           # 🌐 Dash 웹 애플리케이션
│   ├── app.py                          # 🆕 메인 앱 파일 (80줄, 리팩토링됨)
│   ├── app_old.py                      # 📦 기존 파일 백업 (400+ 줄)
│   │
│   ├── core/                           # 🆕 핵심 기능 모듈들
│   │   ├── __init__.py                 # 모듈 초기화
│   │   ├── arduino_manager.py          # Arduino 연결 관리 (80줄)
│   │   ├── data_manager.py             # 데이터 스냅샷 관리 (30줄)
│   │   ├── shared_callbacks.py         # 공통 콜백들 (120줄)
│   │   ├── app_layout.py               # 레이아웃 관리 (80줄)
│   │   └── utils.py                    # 유틸리티 함수들 (30줄)
│   │
│   ├── day_sections/                   # ☀️ Day 모드 관련
│   │   ├── day_layout.py               # Day 레이아웃
│   │   └── day_callbacks.py            # Day 콜백들
│   │
│   ├── night_sections/                 # 🌙 Night 모드 관련
│   │   ├── night_layout.py             # 🆕 Night 레이아웃 (이동됨)
│   │   ├── night_callbacks.py          # Night 콜백들
│   │   ├── sensor_function_buttons_section.py
│   │   ├── combined_graph_section.py
│   │   ├── control_log_section.py
│   │   ├── individual_graphs_section.py
│   │   ├── individual_tools_section.py
│   │   ├── modal_section.py
│   │   └── sensor_temperature_section.py
│   │
│   ├── test_files/                     # 🧪 테스트 도구들 (단독 실행)
│   │   ├── README.md                   # 테스트 도구 사용법
│   │   ├── test_quick.py               # 빠른 연결 테스트 (5초)
│   │   ├── test_arduino_serial_output.py # 기본 시리얼 출력 테스트
│   │   ├── test_safe_debug.py          # 안전한 디버그 (Ctrl+C 지원)
│   │   ├── test_debug_data.py          # 데이터 수신 상태 디버그
│   │   ├── test_detailed.py            # 상세 명령 응답 테스트
│   │   └── test_comprehensive.py       # 포괄적인 시스템 테스트
│   │
│   ├── serial_json_communication.py   # Arduino 시리얼 통신
│   ├── port_manager.py                 # 포트 관리
│   └── white_bar.py                    # UI 유틸리티
│
├── docs_dash/                          # 📚 Dash 관련 문서
│   └── 진행과정.md                     # 개발 진행 과정 기록
│
├── src/                                # 🔧 Arduino 펌웨어 (PlatformIO)
├── tools/                              # 🛠️ 개발 도구들
├── docs/                               # 📖 프로젝트 문서
└── README.md                           # 프로젝트 메인 문서
```

### 🎯 주요 개선사항 요약

1. **📉 코드 간소화**: 메인 파일 400줄 → 80줄 (80% 감소)
2. **🗂️ 모듈화**: 기능별로 독립적인 모듈 분리
3. **🔄 일관성**: Day/Night 모드 대칭 구조 완성
4. **🧪 테스트 정리**: 모든 테스트 도구를 별도 폴더로 분리
5. **📚 문서화**: 각 모듈과 테스트 도구 사용법 문서화
6. **🚀 유지보수성**: 각 기능별 독립적 수정 가능한 구조    **
루트 폴더 파일 정리:**
    - src_dash 루트 폴더의 모든 파일들을 성격별로 분류하여 적절한 폴더로 이동
    - 파일 분류 및 이동 결과:
      - `serial_json_communication.py` → `core/` (핵심 통신 모듈)
      - `port_manager.py` → `core/` (핵심 포트 관리 모듈)  
      - `port_cleanup.py` → `utils/` (개발 유틸리티)
      - `white_bar.py` → `utils/` (UI 테스트 도구)
      - `app_old.py` → `backup/` (백업 파일)
      - `image_preview_dash/` → `assets/screenshots/` (에셋 파일)
    - 새로운 폴더 생성: `utils/`, `backup/`, `assets/`
    - 각 폴더별 README.md 파일 생성하여 용도 문서화
    - Import 경로 수정: core 모듈 내부는 상대 import, 외부는 `from core.module_name import` 사용
    - 최종 결과: 루트에는 `app.py`만 남고 모든 파일이 목적별로 체계적으로 분류됨    **te
st_files 폴더 정리:**
    - core 모듈 이동에 따른 import 경로 수정 완료
    - 모든 테스트 파일의 의존성을 `core.module_name` 형태로 업데이트
    - test_files vs utils 폴더 구분 기준 확립:
      - `test_files/`: Arduino DS18B20 시스템 전용 테스트 도구 (core 모듈 의존)
      - `utils/`: 일반적인 개발 유틸리티 (독립적 실행)
    - test_files/README.md 업데이트하여 새로운 의존성 정보 반영
    - 최종 결정: test_files 폴더 유지 (명확한 목적과 체계적 분류)



    14. 위까지 했던 왠만한 파일에 대한 리팩토링 / 각종 툴에 대한 에러 잡음 (25-08-10)

    15. 다시 웹 대시보드 문제중 자동 실제 연결 모드로 안넘어가는 상황을 해결중 

## 🎉 2025-08-11: 시뮬레이션 모드 → 실제 데이터 모드 자동 전환 문제 해결 완료!

### 🔍 문제 상황
- **현상**: 앱 시작 후 시뮬레이션 모드 진입 → 아두이노 COM4 연결 → 연결 버튼 클릭 → 데이터는 수신되지만 시뮬레이션 모드에서 실제 데이터 모드로 자동 전환되지 않음
- **증상**: 연결 상태 표시는 여전히 "🔴 Arduino 연결 끊김 (시뮬레이션 모드)" 빨간색으로 표시
- **원인**: Arduino 연결 성공 후 `arduino_connected_ref["connected"]` 상태가 `True`로 업데이트되지 않음

### 🛠️ 해결 과정

#### 1. 문제 원인 분석
```python
# 문제가 있던 코드 (day_callbacks.py)
def connect_to_selected_port(n_clicks, selected):
    if arduino.connect():
        if arduino.start_reading():
            print(f"✅ Day 모드 Arduino 연결 성공: {selected}")
            return f"✅ 연결됨: {selected}"
            # ❌ 문제: arduino_connected_ref["connected"] = True 누락!
```

#### 2. 수정된 파일들

**📁 `src_dash/day_sections/day_callbacks.py`**
- `connect_to_selected_port()`: 연결 성공 시 `arduino_connected_ref["connected"] = True` 추가
- `reconnect_arduino()`: 재연결 성공 시 `arduino_connected_ref["connected"] = True` 추가

**📁 `src_dash/night_sections/night_callbacks.py`**  
- `connect_to_selected_port_v2()`: 연결 성공 시 `arduino_connected_ref["connected"] = True` 추가
- `reconnect_arduino_v2()`: 재연결 성공 시 `arduino_connected_ref["connected"] = True` 추가

**📁 `src_dash/core/data_manager.py`**
- 연결 상태 실시간 동기화 로직 추가:
```python
# 🆕 추가된 로직
elif not arduino_connected and arduino.is_healthy():
    # 연결 상태가 False인데 실제로는 건강한 경우 (연결 상태 동기화)
    arduino_connected_ref["connected"] = True
    print("✅ Arduino 연결 상태 복구 감지 - 실제 데이터 모드 전환")
    arduino_connected = True
```

### 🎯 핵심 수정사항

#### Before (문제 상황)
```python
# 연결 성공해도 상태 업데이트 없음
if arduino.connect():
    if arduino.start_reading():
        print("✅ 연결 성공")
        return "✅ 연결됨"
        # arduino_connected_ref["connected"] 업데이트 누락!
```

#### After (해결 후)
```python
# 연결 성공 시 상태 즉시 업데이트
if arduino.connect():
    if arduino.start_reading():
        print("✅ 연결 성공")
        # 🔥 핵심 수정: 연결 상태를 True로 업데이트
        arduino_connected_ref["connected"] = True
        print("🔄 시뮬레이션 모드 → 실제 데이터 모드 전환 완료!")
        return "✅ 연결됨"
    else:
        arduino_connected_ref["connected"] = False
else:
    arduino_connected_ref["connected"] = False
```

### ✅ 해결 결과

**이제 다음과 같이 완벽하게 작동합니다:**

1. **앱 시작** → 🔴 시뮬레이션 모드 (빨간색 상태 표시)
2. **COM4 포트 선택** → 드롭다운에서 COM4 선택
3. **연결 버튼 클릭** → Arduino 연결 시도
4. **연결 성공** → `arduino_connected_ref["connected"] = True` 자동 업데이트
5. **즉시 모드 전환** → 🟢 실제 데이터 모드 (초록색 상태 표시)
6. **실제 데이터 표시** → Arduino에서 받은 실제 온도 데이터 표시

### 🔧 품질 검증
```bash
python tools/auto_lint_and_format.py
```
**결과**: ✅ Ruff: 모든 검사 통과, ✅ Pyright: 타입 체크 통과 (0 errors, 0 warnings)

### 📋 적용 범위
- **Day 모드**: 연결/재연결 버튼 모두 수정 완료
- **Night 모드**: 연결/재연결 버튼 모두 수정 완료  
- **데이터 매니저**: 실시간 상태 동기화 로직 추가
- **양방향 호환**: 두 모드 모두에서 동일하게 작동

이제 사용자가 연결 버튼을 클릭하면 **즉시** 시뮬레이션 모드에서 실제 데이터 모드로 자동 전환되어 실제 Arduino 센서 데이터를 볼 수 있습니다! 🎉

## 🎯 2025-08-11: 센서 주소값 웹 대시보드 표시 기능 구현 완료!

### 🔍 문제 상황
- **현상**: Arduino에서 센서 주소값을 파싱해서 웹 대시보드에 표시하는 기능까지 구현했지만, 정작 주소값이 웹쪽에 표시되지 않는 문제
- **원인**: Arduino 펌웨어에서 센서 주소 정보를 전송하지만, 웹 대시보드에서 이를 요청하지 않아 주소 정보가 수신되지 않음

### 🛠️ 해결 과정

#### 1. Arduino 펌웨어 확인
- Arduino 펌웨어에서 `SCAN_SENSORS` 명령으로 센서 주소 전송 기능 확인
- 실제 센서 주소 정보가 다음 형식으로 전송됨:
  ```
  SYSTEM,SENSOR_1_ADDRESS_28:58:82:84:00:00:00:0E
  SYSTEM,SENSOR_2_ADDRESS_28:5C:82:85:00:00:00:5D
  SYSTEM,SENSOR_3_ADDRESS_28:E6:AA:83:00:00:00:5A
  SYSTEM,SENSOR_4_ADDRESS_28:E7:9B:85:00:00:00:2D
  SYSTEM,SENSOR_5_ADDRESS_28:FF:64:1F:43:B8:23:84
  ```

#### 2. 자동 센서 스캔 기능 추가
**📁 `src_dash/core/serial_json_communication.py`**
```python
def start_reading(self):
    """데이터 읽기 시작"""
    if not self.is_connected:
        self.logger.error("Arduino가 연결되지 않았습니다")
        return False

    self.is_running = True
    self.read_thread = threading.Thread(target=self._read_loop, daemon=True)
    self.read_thread.start()

    # 🔥 센서 주소 정보를 얻기 위해 SCAN_SENSORS 명령 전송
    time.sleep(1)  # Arduino 초기화 대기
    self.send_text_command("SCAN_SENSORS")
    self.logger.info("📍 센서 주소 스캔 명령 전송")

    self.logger.info("📡 데이터 읽기 시작")
    return True
```

#### 3. 센서 주소 파싱 및 저장 기능 확인
- 기존에 구현된 센서 주소 파싱 로직이 정상 작동 확인:
```python
# "SENSOR_1_ADDRESS_28:FF:64:1E:80:16:04:3C" 형식 파싱
if message.startswith("SENSOR_") and "_ADDRESS_" in message:
    parts_addr = message.split("_ADDRESS_")
    if len(parts_addr) == 2:
        sensor_part = parts_addr[0]  # "SENSOR_1"
        address_part = parts_addr[1]  # "28:FF:64:1E:80:16:04:3C"
        sensor_id = int(sensor_part.split("_")[1])  # 1
        
        # 센서 주소 정보 저장
        if not hasattr(self, "sensor_addresses"):
            self.sensor_addresses = {}
        self.sensor_addresses[sensor_id] = address_part
```

#### 4. 웹 UI 표시 기능 확인
- `get_current_temperatures` 메서드에서 센서 주소 정보 포함:
```python
# 🔥 센서 주소 정보 추가
if hasattr(self, "sensor_addresses") and sensor_id in self.sensor_addresses:
    # 콜론 제거하여 16자리 16진수 문자열로 변환
    address_with_colons = self.sensor_addresses[sensor_id]
    address_clean = address_with_colons.replace(":", "")
    temp_info["address"] = address_clean
```

- Day/Night 모드 모두에서 센서 주소 표시:
```python
# 실제 주소가 있는 경우 (예: "28FF641E8016043C")
formatted_address = f"{address[:4]}:{address[4:8]}:{address[8:12]}:{address[12:16]}"
sensor_addresses.append(formatted_address)
```

### ✅ 해결 결과

**완벽한 센서 주소 표시 달성:**

1. **앱 시작** → Arduino 자동 연결 → `SCAN_SENSORS` 명령 자동 전송 ✅
2. **센서 주소 수신** → 5개 센서 주소 정보 파싱 및 저장 ✅
3. **웹 UI 표시** → Day/Night 모드 모두에서 주소 표시 ✅
4. **실시간 갱신** → 1초마다 센서 주소 정보 업데이트 ✅

### 🎯 표시되는 센서 주소 정보

**실제 하드웨어 주소:**
- **센서 1**: `2858:8284:0000:000E`
- **센서 2**: `285C:8285:0000:005D`  
- **센서 3**: `28E6:AA83:0000:005A`
- **센서 4**: `28E7:9B85:0000:002D`
- **센서 5**: `28FF:641F:43B8:2384`

### 🔧 핵심 기술적 개선사항

#### 1. **자동 센서 스캔**
- 앱 시작 시 Arduino 연결 후 자동으로 `SCAN_SENSORS` 명령 전송
- 1초 대기 후 명령 전송으로 Arduino 초기화 완료 보장

#### 2. **주소 포맷팅**
- Arduino에서 받은 콜론 포함 주소 (`28:58:82:84:00:00:00:0E`)
- 콜론 제거 후 4자리씩 구분하여 표시 (`2858:8284:0000:000E`)

#### 3. **실시간 동기화**
- `get_current_temperatures` 메서드에서 센서 주소 정보 실시간 포함
- 웹 UI에서 1초마다 센서 주소 정보 갱신

#### 4. **양방향 호환성**
- Day 모드 (`sensor-{i}-address`): ✅ 주소 표시 완료
- Night 모드 (`sensor-{i}-address`): ✅ 주소 표시 완료
- 시뮬레이션 모드: 더미 주소 표시 (`28FF{i:02d}1E{i:02d}16{i:02d}3C`)

### 📊 품질 검증
- ✅ Arduino 펌웨어: 센서 주소 전송 정상
- ✅ 시리얼 통신: 주소 파싱 및 저장 정상  
- ✅ 데이터 관리: 주소 정보 포함 정상
- ✅ 웹 UI: Day/Night 모드 주소 표시 정상

이제 웹 대시보드에서 각 DS18B20 센서의 **실제 하드웨어 주소**를 확인할 수 있어 센서 식별, 교체, 관리가 훨씬 쉬워졌습니다! 🎯✨

## 🎯 2025-08-11: 포트 드롭다운 현재 연결 포트 표시 문제 해결 완료!

### 🔍 추가 문제 발견
- **현상**: F5 새로고침 후 실제 모드로 잘 진입하지만, 포트 드롭다운이 현재 연결된 COM4가 아닌 COM1로 표시됨
- **사용자 불편**: 실제로는 COM4에 연결되어 있는데 드롭다운은 COM1을 보여줘서 혼란 발생
- **원인**: 포트 드롭다운 갱신 로직에서 현재 Arduino 객체의 연결된 포트 정보를 확인하지 않음

### 🛠️ 해결 과정

#### 1. 문제 분석
```python
# 기존 문제 코드 (day_callbacks.py)
def refresh_port_options(_n, current_value):
    if ports:
        default_val = ports[0].device  # ❌ 항상 첫 번째 포트 (COM1)
    
    value = current_value if current_value in values_set else default_val
    return options, value
```

#### 2. Day 모드 포트 드롭다운 수정 (`day_callbacks.py`)

**핵심 개선사항:**
```python
# 🔥 핵심 수정: 현재 Arduino가 연결된 포트 확인
current_arduino_port = None
if arduino and hasattr(arduino, 'port') and arduino.is_healthy():
    current_arduino_port = arduino.port
    print(f"🔍 [PORT_REFRESH] 현재 Arduino 연결 포트: {current_arduino_port}")

# 현재 연결된 포트를 우선적으로 기본값으로 설정
if current_arduino_port and current_arduino_port in [p.device for p in ports]:
    default_val = current_arduino_port  # ✅ 연결된 포트 (COM4)
    print(f"🎯 [PORT_REFRESH] 연결된 포트를 기본값으로 설정: {default_val}")

# 현재 연결된 포트가 있으면 그것을 우선 선택
if current_arduino_port and current_arduino_port in values_set:
    value = current_arduino_port
    print(f"✅ [PORT_REFRESH] 드롭다운을 연결된 포트로 설정: {value}")
else:
    value = current_value if current_value in values_set else default_val
    print(f"🔄 [PORT_REFRESH] 드롭다운을 기본값으로 설정: {value}")
```

#### 3. Night 모드 포트 드롭다운 수정 (`night_callbacks.py`)

**추가 개선사항:**
- Day 모드와 동일한 현재 포트 감지 로직 적용
- 주기적 갱신을 위해 `interval-component` Input 추가:
```python
# Before: UI 버전 변경 시에만 트리거
@app.callback(
    [Output("port-dropdown-v2", "options"), Output("port-dropdown-v2", "value")],
    [Input("ui-version-store", "data")],
    [State("port-dropdown-v2", "value")],
)

# After: UI 변경 + 주기적 갱신 (1초마다)
@app.callback(
    [Output("port-dropdown-v2", "options"), Output("port-dropdown-v2", "value")],
    [Input("ui-version-store", "data"), Input("interval-component", "n_intervals")],
    [State("port-dropdown-v2", "value")],
)
```

### ✅ 해결 결과

**완벽한 포트 동기화 달성:**

1. **앱 시작** → Arduino 자동 연결 (COM4) → 드롭다운에 COM4 표시 ✅
2. **F5 새로고침** → 실제 데이터 모드 유지 → 드롭다운에 COM4 표시 ✅  
3. **포트 변경** → 다른 포트로 수동 연결 → 드롭다운 자동 업데이트 ✅
4. **연결 해제** → 시뮬레이션 모드 전환 → 드롭다운 기본값 복원 ✅

### 🔧 핵심 기술적 개선사항

#### 1. **실시간 포트 감지**
```python
current_arduino_port = None
if arduino and hasattr(arduino, 'port') and arduino.is_healthy():
    current_arduino_port = arduino.port
```

#### 2. **우선순위 기반 포트 선택**
- **1순위**: 현재 연결된 포트 (`current_arduino_port`)
- **2순위**: 사용자가 선택한 포트 (`current_value`)  
- **3순위**: 시스템 기본값 (`default_val`)

#### 3. **디버그 로깅 강화**
```python
print(f"🔍 [PORT_REFRESH] 현재 Arduino 연결 포트: {current_arduino_port}")
print(f"🎯 [PORT_REFRESH] 연결된 포트를 기본값으로 설정: {default_val}")
print(f"✅ [PORT_REFRESH] 드롭다운을 연결된 포트로 설정: {value}")
```

#### 4. **양방향 호환성**
- Day 모드 (`port-dropdown`): ✅ 수정 완료
- Night 모드 (`port-dropdown-v2`): ✅ 수정 완료
- 두 모드 간 전환 시에도 포트 정보 일관성 유지

### 🎯 사용자 경험 개선

**Before (문제 상황)**:
- 실제 COM4 연결 → 드롭다운은 COM1 표시 → 사용자 혼란 😕

**After (해결 후)**:
- 실제 COM4 연결 → 드롭다운도 COM4 표시 → 직관적 UI 😊

### 📊 품질 검증
```bash
python tools/auto_lint_and_format.py
```
**결과**: 
- ✅ Ruff: 7개 에러 자동 수정, 모든 검사 통과
- ✅ Black: 2개 파일 포맷팅 완료  
- ✅ Pyright: 타입 체크 통과 (0 errors, 0 warnings)

이제 사용자가 F5를 눌러 새로고침해도 포트 드롭다운이 **현재 실제 연결된 Arduino 포트를 정확하게 표시**하여 직관적이고 일관된 사용자 경험을 제공합니다! 🎯✨ 
    
16. 2025-08-11: CI 품질 파이프라인 통합 & 커버리지 도입 완료

### ✅ 개요
- Lint 전용 Workflow → Lint + Tests + Coverage 통합 (`CI Lint & Tests`)
- Python 품질 체인 단일 스크립트: `tools/auto_lint_and_format.py`
- Dev 의존성 분리: `requirements-dev.txt` (ruff, black, autoflake, pyright, types-pyserial, pytest-cov, coverage)
- 코드 커버리지 측정: `pytest --cov=src_dash --cov-report=xml` → coverage.xml 업로드 & Step Summary 표시
- isort 제거 → ruff I 규칙으로 import 정렬 단일화
- pre-commit 훅: auto-lint-format + ruff + black (검증 전용)

### 🛠️ 주요 변경 사항
| 항목                | Before                | After                           |
| ------------------- | --------------------- | ------------------------------- |
| Lint Workflow       | 개별 명령 실행        | 단일 스크립트 + 로그/요약       |
| Import 정렬         | isort                 | ruff (I)                        |
| Dev 패키지          | requirements.txt 혼용 | dev 분리 (requirements-dev.txt) |
| 타입/린트 실패 처리 | 불일관                | ruff/pyright 실패 시 CI fail    |
| Coverage            | 미도입                | pytest + coverage.xml           |
| 로그                | 콘솔 위주             | logs/quality + Step Summary     |

### 📂 생성/수정 파일
```
.github/workflows/ci-lint.yml
requirements-dev.txt
.coveragerc
.pre-commit-config.yaml
tools/auto_lint_and_format.py
README.md
```

### 🔄 파이프라인 순서 (lint 잡)
1. autoflake
2. ruff --fix (I 포함)
3. black
4. ruff check (로그 저장)
5. pyright (타입 검사)

별도 tests 잡:
6. pytest --cov (coverage.xml, term-missing)

### 🚨 CI 실패 조건
| 조건              | 결과                   |
| ----------------- | ---------------------- |
| ruff 코드 != 0    | 실패                   |
| pyright 코드 != 0 | 실패                   |
| pytest 실패       | (현재 허용, 전환 가능) |

### 🧪 로컬 재현
```bash
pip install -r requirements.txt -r requirements-dev.txt
python tools/auto_lint_and_format.py
pytest --cov=src_dash --cov-report=term-missing
```

### 📊 Step Summary 포함
- Ruff 마지막 로그 tail 40줄
- Pyright 마지막 로그 tail 40줄
- 라인 커버리지(line-rate) 표시

### 📁 아티팩트
```
quality-logs/ (Ruff & Pyright)
coverage.xml
```

### 🔍 향후 옵션
- pytest 실패 → CI 실패 전환 (`|| true` 제거)
- Codecov / 커버리지 배지
- tools 디렉토리 일부 포함 커버리지 확장
- 커버리지 임계값 설정 (fail-under)

### 🎯 상태 요약
| 목표                  | 상태 |
| --------------------- | ---- |
| 통합 스크립트 CI 반영 | 완료 |
| Dev 의존성 분리       | 완료 |
| Import 정렬 단일화    | 완료 |
| 커버리지 수집/표시    | 완료 |
| Pre-commit 정리       | 완료 |

로컬/CI 품질 체인 일관성과 가시성이 향상되어 확장(배지, threshold) 준비가 완료된 상태.
